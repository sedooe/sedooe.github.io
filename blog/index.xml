<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>sedooe</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://sedooe.github.io/blog/</link>
    <language>en-us</language>
    <author>Sedat Gokcen</author>
    
    <updated>Mon, 17 Apr 2017 00:00:00 UTC</updated>
    
    
    <item>
      <title>Intercepting and modifying logs in Logback</title>
      <link>http://sedooe.github.io/2017/04/intercepting-and-modifying-logs-in-logback/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 UTC</pubDate>
      <author>Sedat Gokcen</author>
      <guid>http://sedooe.github.io/2017/04/intercepting-and-modifying-logs-in-logback/</guid>
      <description>&lt;p&gt;Actually, Logback does not offer a direct way to modify logs but there is a workaround we can achieve our goal by using filter even though it looks like a bit hacky.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that you logged some id no of some user hundreds of times, it scattered through all over the application and now you have a new requirement that says you have to encrypt this id number. Of course you&amp;rsquo;re smart enough to write an interceptor for this task instead of go find and change necessary logs manually. And also with this way, we can be sure that we&amp;rsquo;ll never log that id number accidentally.&lt;/p&gt;

&lt;p&gt;For this case, we&amp;rsquo;re gonna extend &lt;a href=&#34;https://logback.qos.ch/apidocs/ch/qos/logback/classic/turbo/TurboFilter.html&#34;&gt;&lt;code&gt;TurboFilter&lt;/code&gt;&lt;/a&gt; and override its &lt;code&gt;decide&lt;/code&gt; method.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/sedooe/a1658c2fb7ae89084b2f21457321f0e2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;If the log matches our criteria and we want to change it, we deny it by returning &lt;code&gt;FilterReply.DENY&lt;/code&gt; and log again with the changed object.&lt;/p&gt;

&lt;p&gt;Here, I used &lt;code&gt;info&lt;/code&gt; as log level for the sake of simplicity but if you don&amp;rsquo;t want to change log level, you can easily check which &lt;code&gt;level&lt;/code&gt; coming log has and use that level.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s that easy once you deal with recursion and not forget to declare your custom filter in configuration file properly.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/sedooe/97f93f124dae080c9d958d1689c1697e.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CORS and Authentication</title>
      <link>http://sedooe.github.io/2016/08/cors-and-authentication/</link>
      <pubDate>Sun, 28 Aug 2016 00:00:00 UTC</pubDate>
      <author>Sedat Gokcen</author>
      <guid>http://sedooe.github.io/2016/08/cors-and-authentication/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say that you have an API which stands on &lt;strong&gt;xdomain.com&lt;/strong&gt; and you have a Javascript application that consuming this API from &lt;strong&gt;ydomain.com&lt;/strong&gt;. For ydomain.com to consume the API, xdomain.com has to send &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&#34;&gt;CORS&lt;/a&gt; header  &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; in its response.&lt;/p&gt;

&lt;p&gt;The simplest way to do this in Spring is annotate whole controller or just handler method with the annotation &lt;a href=&#34;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html&#34;&gt;&lt;code&gt;CrossOrigin&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s all what you need when your API does not require authentication.&lt;/p&gt;

&lt;p&gt;On the other hand, when your API requires authentication, things get a bit complicated. For example, let&amp;rsquo;s say that you authenticate your API with HTTP Basic Authentication. So, consumers of this API must send an &lt;strong&gt;Authorization&lt;/strong&gt; header which contains user credentials in their request. Since this is a &lt;a href=&#34;http://stackoverflow.com/a/10636765/3099704&#34;&gt;non-simple request&lt;/a&gt;, &lt;strong&gt;OPTIONS&lt;/strong&gt; request will be send firstly. The thing is that, even if you send Authorization header with correct credentials in your request, you will face something like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.sedooe.com/img/options_response.png&#34; alt=&#34;response&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The reason of this is, according to CORS spec, it excludes your Authorization header. Hence, you should permit OPTIONS requests in your security configuration class explicitly.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/sedooe/5c5735ca41a96a6d7be7a73d783334ba.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Last of all, I suggest you to read these two posts:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/a/15734032/3099704&#34;&gt;http://stackoverflow.com/a/15734032/3099704&lt;/a&gt;
&lt;a href=&#34;https://code.google.com/archive/p/twitter-api/issues/2273&#34;&gt;https://code.google.com/archive/p/twitter-api/issues/2273&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>REST Authentication using Spring Security &amp; Spring Session</title>
      <link>http://sedooe.github.io/2016/04/rest-authentication-using-spring-security-and-spring-session/</link>
      <pubDate>Sat, 16 Apr 2016 00:00:00 UTC</pubDate>
      <author>Sedat Gokcen</author>
      <guid>http://sedooe.github.io/2016/04/rest-authentication-using-spring-security-and-spring-session/</guid>
      <description>&lt;p&gt;In this post, I will try to demonstrate how easily we can implement an authentication mechanism for REST services using Spring Security and Spring Session with the help of Redis.&lt;/p&gt;

&lt;p&gt;The authentication scheme that we will use:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Client requests an authenticated URL with its credentials. (first request to the server)&lt;/li&gt;
&lt;li&gt;Server gives some unique string besides the normal response. &lt;/br&gt;(unique string is session id in our case)&lt;/li&gt;
&lt;li&gt;Client has to send this string with every request using an HTTP header.&lt;/li&gt;
&lt;li&gt;Server recognizes this unique string and logs client in.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Let&amp;rsquo;s start implementing the scheme above.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For this application to work, you must install Redis 2.8+ on localhost and run it with the default port (6379).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will create very simple Spring Boot application which you can get source code and dependencies &lt;a href=&#34;https://github.com/sedooe/blog-projects/tree/master/rest-authentication-example&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our security configuration looks like:
&lt;script src=&#34;https://gist.github.com/sedooe/f143f6b615bfc1aeb23954ef514ec244.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;configureGlobal&lt;/code&gt; method is pretty straightforward, we just create a user with username &lt;em&gt;sedooe&lt;/em&gt; and password &lt;em&gt;password&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;configure&lt;/code&gt; method is also straightforward but I want to emphasize two things here.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We are using HTTP Basic Authentication since it is simplest way to deal with authentication. As you probably know, Basic Authentication is just a standard HTTP header with the username:password encoded in base64: &lt;/br&gt;
&lt;code&gt;Authorization: Basic c2Vkb29lOnBhc3N3b3Jk&lt;/code&gt; &lt;/br&gt;
Keep in mind that encoding is not encrypting. Therefore, you must use HTTPS instead of HTTP to make sure that user credentials are sent securely.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;NullRequestCache&lt;/code&gt; prevents creation of session when user is not authenticated so that we have only authenticated users&amp;rsquo; session ids stored in Redis.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In &lt;code&gt;httpSessionStrategy&lt;/code&gt; method, Spring Session comes into play. &lt;/br&gt;
Thanks to &lt;code&gt;HeaderHttpSessionStrategy&lt;/code&gt;, when a session is created, the HTTP response will have a response header of the specified name and the value of the session id. Default header name is &lt;strong&gt;x-auth-token&lt;/strong&gt; and we will use it.&lt;/p&gt;

&lt;p&gt;Here is our simple controller:
&lt;script src=&#34;https://gist.github.com/sedooe/0f1536cfccb3024b1090fb73b895f718.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;There is nothing to mention about this controller specifically so let&amp;rsquo;s start trying things out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ curl -v http://localhost:8080/api/resource&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Yeah, authentication is required to access this resource. So try:&lt;/br&gt;
&lt;code&gt;$ curl -v http://localhost:8080/api/resource -u sedooe:password&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now you are authenticated and you have access to the resource. Take a look at response headers and you will see that:&lt;/br&gt;
&lt;code&gt;x-auth-token: 00661f53-8453-4daf-89f1-e748a3326040&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For further requests, we can use &lt;strong&gt;x-auth-token&lt;/strong&gt; instead of username and password.&lt;/br&gt;
&lt;code&gt;$ curl -v http://localhost:8080/api/resource -H &amp;quot;x-auth-token: 00661f53-8453-4daf-89f1-e748a3326040&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you want to see all stored tokens:&lt;/br&gt;
&lt;code&gt;$ redis-cli keys &#39;*&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To invalidate the session and delete it from Redis:&lt;/br&gt;
&lt;code&gt;$ curl -v http://localhost:8080/api/logout -H &amp;quot;x-auth-token: 00661f53-8453-4daf-89f1-e748a3326040&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You may wonder how our application connected to Redis without writing any code for that.&lt;/p&gt;

&lt;p&gt;Since we use Spring Boot 1.3.3 in this project and Spring Session and Spring Data Redis are both on the classpath, Spring Boot will auto-configure Spring Session to connect to Redis.&lt;/p&gt;

&lt;p&gt;If you use earlier Spring Boot versions than 1.3.1 or don&amp;rsquo;t use it at all, you should add &lt;a href=&#34;http://docs.spring.io/spring-session/docs/current/api/org/springframework/session/data/redis/config/annotation/web/http/EnableRedisHttpSession.html&#34;&gt;&lt;code&gt;@EnableRedisHttpSession&lt;/code&gt;&lt;/a&gt; to your configuration class.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    
  </channel>
</rss>